<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>EV vs Clean Electricity</title>

        <!-- =============================
         Task 10: Basic Visualization Structure
         - Load D3.js, Leaflet, MarkerCluster
         - Prepare for chart + map
        ============================== -->
    
        <!-- D3.js -->
        <script src="https://d3js.org/d3.v7.min.js"></script>
        <script src="https://unpkg.com/d3-svg-annotation@2.5.1/d3-annotation.min.js"></script>

        <!-- Leaflet -->
        <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css"/>
        <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>

        <!-- Leaflet MarkerCluster -->
        <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css"/>
        <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css"/>
        <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>

        <!-- Task 14: Styles include responsive design -->
        <style>
            body { font-family: sans-serif; margin:0; padding:0; background: #fae5e9;}
            h1 { text-align: center; margin: 20px 0; color: #864b69; font-weight: 600; }
            h2 { text-align: center; margin: 20px 0; color: #864b69; font-weight: 500; font-size: 20px;}
            p { text-align:center; font-size:14px; color: #7a7aae; font-size: 14px; margin-bottom: 10px; }
            .dashboard-container { display: flex; width: 92%; height: 90vh; gap: 20px;}
            #controls { color: #7a7aae; min-height: 44px; text-align:center; margin: 15px; }
            #map { width: 100%; height: 520px; margin: 10px 0; }
            #chart { width: 100%; height: 480px; margin: 10px 0; display:block; }
            #map, #chart { background: #ffffff; border: 2px solid #f6b8bf; border-radius: 8px; padding: 4px; box-shadow: 0 2px 5px rgba(0,0,0,0.15); }
            #chart svg { width: 100%; height: 100%; display: block; }
            #tooltip { position:absolute; background:white; border:1px solid #ccc; padding:6px; display:none; pointer-events:none; border-radius: 6px; box-shadow: 0 2px 6px rgba(0,0,0,0.15);}
            .loading { min-height: 12px; text-align:center; font-size:10px; padding:5px; }
            .loading.loaded { visibility: hidden; }
            .info.legend { background: #f1f6ff; padding: 8px 10px; border-radius: 8px; font-size:10px; box-shadow: 0 3px 8px rgba(0,0,0,0.15);  line-height: 1.4em; }
            .info.legend i { border: 1px solid #ccc; }
            .annotation-note-title { font-size: 10px; font-weight: bold; }
            .annotation-note-label { font-size: 9px; }
            .leaflet-bottom.leaflet-right { min-height: 50px; min-width: 120px; }

            #story-panel { width: 25%; height: 1275px; overflow-y: auto; padding: 15px; background: #fff6fa; border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.08); position: relative; }
            #visuals-panel { width: 75%; overflow-y: auto; }
            #story { max-width: 900px; margin: 10px auto 30px auto; }
            .step { margin: 30px 0; padding: 18px; background: white; border-radius: 12px; box-shadow: 0 2px 6px rgba(0,0,0,0.08); }
            .step p { text-align:left; color:#555; }
            .step.is-active { border-left: 6px solid #fddde1; background: linear-gradient(90deg, #fff, #fff6f9); }


            /* Tablet */
                @media (max-width: 1024px) {
                #map, #chart { height: 400px; }
                h1 { font-size: 20px; }
                h2 { font-size: 15px; }
                p { font-size: 12px; }
                #map, #chart { height: 300px; }
                .dashboard-container { padding: 10px; }
                .step { margin: 15px 0; padding: 10px; font-size: 10px; }
                .step h2 { font-size: 10px; margin-bottom: 4px; }
                .step p { font-size: 8px; }
                #story-panel { width: 25%; height: 900px; }
            }

            /* Mobile */
            @media (max-width: 600px) {
                h1 { font-size: 18px; }
                h2 { font-size: 14px; }
                p { font-size: 10px; }
                #map, #chart { height: 150px; }
                .dashboard-container { padding: 10px; }
                #controls { display: block; grid-auto-flow: row; min-height: 96px;}
                #controls label { font-size: 12px; display: block; margin-top: 10px; }
                #controls select { font-size: 10px; width: 100%; margin-bottom: 10px; }
                .info.legend { background: #f1f6ff; padding: 1px 1px; border-radius: 5px; font-size:5px; box-shadow: 0 3px 8px rgba(0,0,0,0.15);  line-height: 1em; }
                .info.legend i { border: 1px solid #ccc; width: 12px !important; height: 12px !important; margin-right: 0px !important; }
                .info.legend svg { width: 60px !important; height: 20px !important; }
                .annotation-note-title { font-size: 7px !important; }
                .annotation-note-label { font-size: 6px !important; }
                .step { margin: 15px 0; padding: 10px; font-size: 10px; }
                .step h2 { font-size: 10px; margin-bottom: 4px; }
                .step p { font-size: 8px; }
                #story-panel { width: 50%; height: 700px; }
            }

        </style>
        
    </head>
    <body>
        <div class="dashboard-container">
            <!-- Storytelling container (Task 18) -->
             <div id="story-panel">
                <div id="story">
                    <div class="step" data-step="intro">
                        <h2>Introduction</h2>
                        <p>Hypothesis: Cleaner electricity → more EV adoption. Let’s see if the data supports it.</p>
                    </div>
                    <div class="step" data-step="global">
                        <h2>No Strong Global Link</h2>
                        <p>Globally, correlations are weak or contradictory. Grid cleanliness alone does not explain EV adoption.</p>
                    </div>
                    <div class="step" data-step="europe">
                        <h2>Regional Differences: Europe</h2>
                        <p>Europe trends slightly negative: cleaner grids correlate with more EV adoption, but weakly.</p>
                    </div>
                    <div class="step" data-step="northamerica">
                        <h2>Regional Differences: North America</h2>
                        <p>Here, the link is actually positive: more carbon-intensive grids see higher EV adoption — reflecting strong policy and incentives.</p>
                    </div>
                    <div class="step" data-step="asiapacific">
                        <h2>Regional Differences: Asia & Pacific</h2>
                        <p>Mixed picture: large EV markets like China coexist with fossil-heavy grids.</p>
                    </div>
                    <div class="step" data-step="clusters">
                        <h2>Spatial Clustering</h2>
                        <p>EV adoption hubs are concentrated in Europe, China/East Asia, and North America — driven by policy, supply chains, and incentives.</p>
                    </div>
                    <div class="step" data-step="local">
                        <h2>Local Relationships</h2>
                        <p>Local regressions differ: Nordics show negative slopes, while North America/East Asia tilt positive. Global averages blur these differences.</p>
                    </div>
                    <div class="step" data-step="anomalies">
                        <h2>Patterns & Anomalies</h2>
                        <p>Outliers like Norway (clean + high EVs) or China/US (high EVs despite dirtier grids) illustrate how market and policy dominate.</p>
                    </div>
                    <div class="step" data-step="cautions">
                        <h2>Cautions</h2>
                        <p>Beware scale effects, lags, omitted variables, and pooled data. Correlation ≠ causation.</p>
                    </div>
                    <div class="step" data-step="conclusion">
                        <h2>Conclusion</h2>
                        <p>No universal global link. Regional and local factors matter most. Policies, incentives, and market size shape EV adoption more than grid cleanliness.</p>
                    </div>
                </div>
            </div>

            <div class = "visuals-panel">
                <h1>Does Clean Electricity Drive Electric Vehicle Adoption?</h1>
                <div id="controls">
                    <label for="yearSelect"><b>Select Year:</b></label>
                    <select id="yearSelect"></select>

                    <label for="regionSelect"><b>Select Region:</b></label>
                    <select id="regionSelect"></select>
                </div>
                <div class="loading" id="loading">Loading data...</div>

                <!-- Map title -->
                <h2>Global Electric Vehicle Adoption & Clean Electricity</h2>
                <p>Some bubbles are clustered—click a cluster to see the individual countries.</p>
                <div id="map"></div>

                <!-- Scatter plot title -->
                <h2>Clean Electricity Share vs. Electric Vehicle Sales</h2>
                <p>Each bubble represents a country in the selected year/region.</p>
                <div id="chart"></div>
            </div>
        </div>
        <div id="tooltip"></div>

        <script>

            // =============================
            // Task 10: Basic Visualization Structure
            // - Set up SVG, scales, axes, labels
            // =============================

            const chartDiv = document.getElementById('chart');
            const chartWidth = 1000;
            const chartHeight = 440;
            const margin = {top: 30, right: 100, bottom: 50, left: 80};
            const innerW = chartWidth - margin.left - margin.right;
            const innerH = chartHeight - margin.top - margin.bottom;

            let currentAnnotations = [];
            let currentData = [];
            let fullData = [];

            const svg = d3.select("#chart")
                .append("svg")
                .attr("viewBox", `0 0 ${chartWidth} ${chartHeight}`)
                .attr("preserveAspectRatio", "xMidYMid meet")
                .append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            // Task 10: Scales
            const xScale = d3.scaleLinear().range([0, innerW]);
            const yScale = d3.scaleLinear().range([innerH, 0]);
            const sizeScale = d3.scaleSqrt().range([3, 20]);
            const colorScale = d3.scaleSequential(d3.interpolateRgb("pink", "steelblue"));

            // Task 10: Axes
            svg.append("g").attr("class","x-axis").attr("transform", `translate(0, ${innerH})`);
            svg.append("g").attr("class","y-axis");

            // Task 10: Labels
            svg.append("text")
                .attr("class","x-label")
                .attr("x", innerW/2)
                .attr("y", innerH + 48)
                .attr("text-anchor","middle").
                text("Clean Electricity Share (%)");

            svg.append("text")
                .attr("class","y-label")
                .attr("x", -innerH / 2)       
                .attr("y", -60)              
                .attr("transform", "rotate(-90)")
                .attr("text-anchor", "middle")
                .text("Electric Cars Sold");

            // =============================
            // Task 13: Annotations
            // - Function to draw d3-annotations
            // =============================

            function drawAnnotations(annotations, transform = null) {
                svg.selectAll(".annotation-group").remove();

                if (annotations.length === 0) return;

                const ann = annotations.map(a => {
                    const x = transform ? transform.applyX(xScale(a.dataPoint.CleanElec)) : xScale(a.dataPoint.CleanElec);
                    const y = transform ? transform.applyY(yScale(a.dataPoint.EV)) : yScale(a.dataPoint.EV);
                    return {
                        note: a.note,
                        x, y,
                        dx: a.dx,
                        dy: a.dy
                    };
                });

                const makeAnnotations = d3.annotation().annotations(ann).notePadding(5);
                svg.append("g").attr("class","annotation-group").call(makeAnnotations);
            }

            // =============================
            // Task 15: Performance Optimization
            // - Throttle zoom and brush to avoid excessive redraws
            // =============================
            
            function throttle(func, delay) {
                let lastCall = 0;
                return function(...args) {
                    const now = Date.now();
                    if (now - lastCall >= delay) {
                        lastCall = now;
                        func.apply(this, args);
                    }
                }
            }

            // =============================
            // Task 12: Interactivity
            // - Zoom behavior with throttle
            // =============================

            const zoom = d3.zoom()
                .scaleExtent([0.5, 10])
                .translateExtent([[0, 0], [chartWidth, chartHeight]])
                .on("zoom", throttle(zoomed, 16));

            d3.select("svg").call(zoom);
            function zoomed({transform}) {
                const newX = transform.rescaleX(xScale);
                const newY = transform.rescaleY(yScale);

                // Update circles
                svg.selectAll("circle").each((d, i, nodes) => {
                    if (d) {
                        d3.select(nodes[i])
                        .attr("cx", newX(d.CleanElec))
                        .attr("cy", newY(d.EV));
                    }
                });

                // Update axes
                svg.select(".x-axis").call(d3.axisBottom(newX));
                svg.select(".y-axis").call(d3.axisLeft(newY));

                // Update annotations
                drawAnnotations(currentAnnotations, transform);
            }

            // Task 12: Tooltip
            const tooltip = d3.select("#tooltip");

            // =============================
            // Task 10 & 11: Leaflet Map Setup
            // - Base map, tile layers
            // =============================

            const map = L.map('map', { center: [20, 0], zoom: window.innerWidth < 768 ? 1 : 2, zoomControl: true, dragging: true, tap: true, scrollWheelZoom: false });
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                maxZoom: 18,
                attribution: '&copy; OpenStreetMap contributors'
            }).addTo(map);

            let leafletLayer;
            const markerMap = {}; 

            // =============================
            // Task 16: Error Handling
            // - Load data with backup option
            // =============================

            d3.json("data/master_data.geojson").then(geoData => processGeoData(geoData))
            .catch(error => {
                console.warn("Primary dataset failed, trying backup:", error);
                d3.json("data/master_data_backup.geojson")
                    .then(geoData => processGeoData(geoData))
                    .catch(error2 => {
                        console.error("Backup dataset failed too:", error2);
                        d3.select("#loading")
                        .style("display", "block")
                        .text("Failed to load both primary and backup data.");
                    });
            });

            // =============================
            // Task 11: Main Visualizations
            // - Clean and validate data
            // =============================
            
            function processGeoData(geoData) {
                const masterData = geoData.features.map(f => {
                    const p = f.properties;
                    if (!p.Country || !p.Region || !p.Year || !p.EV || !p.CleanElec ) {
                        console.warn("Invalid data point skipped:", p);
                        return null;
                    }
                    return {
                        Country: p.Country,
                        Region: p.Region,
                        Year: +p.Year,
                        EV: +p.EV,
                        CleanElec: +p.CleanElec,
                        lat: f.geometry.coordinates[1],
                        lon: f.geometry.coordinates[0]
                    };
                }).filter(d => d !== null);

                console.info("Data loaded successfully:", masterData.length, "points.");
                fullData = masterData;

                const maxEVOverall = d3.max(masterData, d => d.EV);
                sizeScale.domain([0, maxEVOverall]);

                // =============================
                // Task 12: Interactivity
                // - Filtering with dropdowns
                // =============================

                // Year dropdown
                const years = ["All years", ...d3.range(2010, 2021)];
                const yearSelect = d3.select("#yearSelect");
                yearSelect.selectAll("option")
                    .data(years)
                    .enter().append("option")
                    .text(d => d)
                    .attr("value", d => d);

                // Region dropdown
                const regions = ["All regions", ...Array.from(new Set(masterData.map(d => d.Region)))];
                const regionSelect = d3.select("#regionSelect");

                regionSelect.selectAll("option")
                    .data(regions)
                    .enter().append("option")
                    .text(d => d)
                    .attr("value", d => d);

                function filterData() {
                    const year = yearSelect.property("value");
                    const region = regionSelect.property("value");

                    let filtered = masterData;

                    if (year !== "All years") filtered = filtered.filter(d => d.Year === +year);
                    if (region !== "All regions") filtered = filtered.filter(d => d.Region === region);

                    currentData = filtered;
                    
                    if (currentData.length === 0) {
                        d3.select("#loading").style("display", "block").text("No data available for the selected year/region.");
                        svg.selectAll("circle").remove();
                        return;
                    } else {
                        d3.select("#loading").style("display", "none");
                    }
                    
                    try { updateChart(currentData);
                    } catch(e) { console.error("Error updating chart:", e); }

                    try { updateMap(currentData);
                    } catch(e) { console.error("Error updating map:", e); }

                    // Reset zoom on filtering
                    d3.select("svg").transition().duration(500).call(zoom.transform, d3.zoomIdentity);
                }

                yearSelect.on("change", filterData);
                regionSelect.on("change", filterData);

                // =============================
                // Task 12: Brush
                // =============================
                const brush = d3.brush()
                    .extent([[0,0], [innerW, innerH]])
                    .on("end", throttle(brushed, 16));

                svg.append("g").attr("class", "brush").call(brush);

                function brushed({selection}) {
                    if (!selection) {
                        updateMap(currentData);
                        return;
                    }
                    const [[x0,y0],[x1,y1]] = selection;
                    const selected = currentData.filter(d => {
                        const cx = xScale(d.CleanElec);
                        const cy = yScale(d.EV);
                        return cx >= x0 && cx <= x1 && cy >= y0 && cy <= y1;
                    });
                    updateMap(selected);

                    // Zoom map to selection
                    if (selected.length > 0) {
                        const bounds = L.latLngBounds(selected.map(d => [d.lat, d.lon]));
                        map.fitBounds(bounds, { padding: [30, 30], maxZoom: 5 });
                    };
                }

                window.masterData = masterData;
                window.fullData = fullData;

                // Initial state
                yearSelect.property("value", "All years");
                regionSelect.property("value", "All regions");
                filterData();
                d3.select("svg").transition().duration(500).call(zoom.transform, d3.zoomIdentity);

                // =============================
                // Task 11: Update Scatter Plot
                // - Enter/update/exit pattern
                // =============================

                function updateChart(data) {

                    xScale.domain([0, d3.max(data, d => d.CleanElec)]).nice();
                    yScale.domain([0, d3.max(data, d => d.EV)]).nice();
                    colorScale.domain([0, d3.max(data, d => d.CleanElec)]);

                    svg.select(".x-axis").transition().duration(500).call(d3.axisBottom(xScale));
                    svg.select(".y-axis").transition().duration(500).call(d3.axisLeft(yScale));

                    const circles = svg.selectAll("circle").data(data, d => d ? (d.Country + d.Year) : this);

                    circles.enter().append("circle")
                        .attr("opacity", 0.9)
                        .on("mouseover", (event, d) => {
                            tooltip.style("display","block")
                            .html(`<b>${d.Country}</b><br>EV: ${d.EV.toLocaleString()}<br>Clean Elec: ${(d.CleanElec).toFixed(2)}%`);
                            // Highlight map marker
                            const key = d.Country + d.Year;
                            if (markerMap[key]) markerMap[key].setStyle({color:"yellow", weight:3});
                        })
                        .on("mousemove", event => {
                            tooltip.style("left", (event.pageX+10)+"px")
                                .style("top", (event.pageY-20)+"px");
                        })
                        .on("mouseout", (event, d) => {
                            tooltip.style("display","none");
                            const key = d.Country + d.Year;
                            if (markerMap[key]) markerMap[key].setStyle({color:"#333", weight:1});
                        })
                        .on("click", (event, d) => {
                            const latlng = L.latLng(d.lat, d.lon);
                            map.flyTo(latlng, 4, { animate: true, duration: 1 }); 
                            const marker = markerMap[d.Country + d.Year];
                            if (marker) marker.openPopup();
                        })
                        .merge(circles)
                        .transition().duration(500)
                        .attr("cx", d => xScale(d.CleanElec))
                        .attr("cy", d => yScale(d.EV))
                        .attr("r", d => sizeScale(d.EV))
                        .attr("fill", d => colorScale(d.CleanElec));

                    circles.exit().remove();

                    // =============================
                    // Task 13: D3 Annotations
                    // =============================
                    svg.selectAll(".annotation-group").remove();

                    currentAnnotations = []; 

                    if (data.length > 0) {
                        const maxEV = d3.max(data, d => d.EV);
                        const minEV = d3.min(data, d => d.EV);
                        const top = data.find(d => d.EV === maxEV);
                        const low = data.find(d => d.EV === minEV);

                        function safeOffsets(x, y) {
                            let dx = 30, dy = -30;
                            if (x > innerW * 0.7) dx = -50;
                            if (y < 40) dy = 40;    
                            if (y > innerH - 40) dy = -40;
                            return {dx, dy};
                        }
                        window.safeOffsets = safeOffsets;

                        if (top) {
                            const {dx, dy} = safeOffsets(xScale(top.CleanElec), yScale(top.EV));
                            currentAnnotations.push({
                                note: { title: "Highest EV", label: top.Country, wrap: 120 },
                                dataPoint: top,
                                dx, dy
                            });
                        }
                        if (low) {
                            const {dx, dy} = safeOffsets(xScale(low.CleanElec), yScale(low.EV));
                            currentAnnotations.push({
                                note: { title: "Lowest EV", label: low.Country, wrap: 120 },
                                dataPoint: low,
                                dx, dy
                            });
                        }
                        drawAnnotations(currentAnnotations); 
                    }
                    updateLegends(data);
                }

                // =============================
                // Task 11: Update Leaflet Map
                // - Markers, clustering, popups
                // =============================

                function updateMap(data, options = {}) {
                    if (leafletLayer) map.removeLayer(leafletLayer);

                    const suppressFitBounds = options.suppressFitBounds || false;

                    leafletLayer = L.markerClusterGroup({
                        removeOutsideVisibleBounds: false
                    });
                    Object.keys(markerMap).forEach(k => delete markerMap[k]);

                    data.forEach(d => {
                            const marker = L.circleMarker([d.lat, d.lon], {
                            radius: 4 + sizeScale(d.EV)/2,
                            fillColor: colorScale(d.CleanElec),
                            color: "#333",
                            weight: 1,
                            fillOpacity: 0.9
                        }).bindPopup(`
                        <b>${d.Country} (${d.Year})</b><br>
                        EV Sales: ${d.EV.toLocaleString()}<br>
                        Clean Electricity: ${(d.CleanElec).toFixed(2)}%
                        `);

                        // Link back to chart
                        marker.on("mouseover", () => {
                            d3.selectAll("circle")
                                .filter(c => c && c.Country === d.Country && c.Year === d.Year)
                                .classed("highlight", true);
                        });
                        marker.on("mouseout", () => {
                            d3.selectAll("circle").classed("highlight", false);
                        });

                        markerMap[d.Country + d.Year] = marker;
                        leafletLayer.addLayer(marker);
                    });

                    leafletLayer.addTo(map);

                    // Zoom map to fit filtered data
                    if (!suppressFitBounds && data.length > 0) {
                        const bounds = L.latLngBounds(data.map(d => [d.lat, d.lon]));
                        map.fitBounds(bounds, { padding: [30, 30] });
                    }
                }

                // =============================
                // Task 13: Legends (D3 + Leaflet)
                // =============================

                function updateLegends(data){
                    d3.selectAll(".color-legend").remove();
                    d3.selectAll(".size-legend").remove();

                    const isMobile = window.innerWidth < 600;
                    const fontSize = isMobile ? "12px" : "10px";

                    // D3 Color Legend (top-right)
                    const colorLegend = svg.append("g")
                        .attr("class","color-legend")
                        .attr("transform",`translate(${innerW - (isMobile ? 20 : 0)}, 10)`);

                    
                    colorLegend.append("text")
                        .attr("x",0).attr("y",-5)
                        .style("font-weight","bold")
                        .style("font-size",fontSize)
                        .text("Clean Electricity (%)");

                    const legendData = d3.range(0, d3.max(data,d=>d.CleanElec), 20);
                    
                    colorLegend.selectAll("rect").data(legendData).enter()
                        .append("rect")
                        .attr("x",0).attr("y",(d,i)=> i*18)
                        .attr("width",12).attr("height",12)
                        .attr("fill",d=>colorScale(d));

                    colorLegend.selectAll("text.label").data(legendData).enter()
                        .append("text")
                        .attr("class","label")
                        .attr("x",18).attr("y",(d,i)=> i*18+10)
                        .style("font-size",fontSize)
                        .text(d=>d+"%");

                    // D3 Size Legend
                    const sizeLegend = svg.append("g")
                        .attr("class","size-legend")
                        .attr("transform", `translate(${innerW - (isMobile ? 15 : -10)}, ${legendData.length * 18 + 40})`);

                    sizeLegend.append("text")
                        .attr("x",0).attr("y",-10)
                        .style("font-weight","bold")
                        .style("font-size",fontSize)
                        .text("EV Sales");

                    const sizeValues = [50000, 200000, 500000]; 

                    // Compute cumulative y positions to prevent overlap
                    let cumulativeY = 0;
                    sizeValues.forEach((d, i) => {
                        const r = sizeScale(d);
                        const cy = cumulativeY + r;
                        sizeLegend.append("circle")
                            .attr("cy", cy)
                            .attr("r", r)
                            .attr("fill","steelblue")
                            .attr("opacity",0.5);
                        
                        sizeLegend.append("text")
                            .attr("x", r + 5)
                            .attr("y", cy)
                            .attr("alignment-baseline","middle")
                            .style("font-size",fontSize)
                            .text(d.toLocaleString());

                        cumulativeY += 2 * r + 5; 
                    });

                }

                // Leaflet Legend
                const legend = L.control({position:"bottomright"});
                legend.onAdd = function(map){
                    const div = L.DomUtil.create("div","info legend");

                    const isMobile = window.innerWidth < 600;

                    // Adjust font and box size for mobile
                    const labelFontSize = isMobile ? "5px" : "12px";
                    const boxSize = isMobile ? 8 : 18;
                    const marginRight = isMobile ? 3 : 5;

                    div.innerHTML += `<b style="font-size:${labelFontSize}">Clean Electricity (%)</b><br>`;

                    const grades = [0, 20, 40, 60, 80, 100];
                    const labels = ["0–19", "20–39", "40–59", "60–79", "80–100"];

                    grades.forEach((g, i) => {
                        if (i < labels.length) {
                            div.innerHTML +=
                                `<i style="background:${colorScale(g)}; width:${boxSize}px; height:${boxSize}px; display:inline-block; margin-right:${marginRight}px"></i>
                                ${labels[i]}%<br>`;
                        }
                    });

                    div.innerHTML += `<br><b style="font-size:${labelFontSize}">EV Sales (circle size)</b><br>`;
                    const svgWidth = isMobile ? 60 : 100;
                    const svgHeight = isMobile ? 30 : 60;
                    const smallCircleR = isMobile ? 2 : 5;
                    const largeCircleR = isMobile ? 5 : 10;
                    const textFont = isMobile ? 6 : 12;

                    div.innerHTML += `<svg width="${svgWidth}" height="${svgHeight}">
                        <circle cx="15" cy="${isMobile?4:15}" r="${smallCircleR}" fill="steelblue" opacity="0.6"/>
                        <text x="30" y="${isMobile?6:18}"  font-size="${textFont}">5k</text>
                        <circle cx="15" cy="${isMobile?15:45}" r="${largeCircleR}" fill="steelblue" opacity="0.6"/>
                        <text x="30" y="${isMobile?16:50}" font-size="${textFont}">500k</text>
                    </svg>`;

                    return div;
                };

                legend.addTo(map);
                L.control.scale({metric:true, imperial:false}).addTo(map);

                window.updateChart = updateChart;
                window.updateMap = updateMap;
                window.drawAnnotations = drawAnnotations;
                window.filterData = filterData;
                runVisualizationTests();
            }

            // =============================
            // Task 18: Storytelling — click-driven activation
            // =============================

            function findLatestForCountry(country) {
                if (!window.fullData || window.fullData.length === 0) return null;
                const arr = window.fullData.filter(d=>d.Country === country);
                if (!arr || arr.length === 0) return null;
                return arr.sort((a,b)=>b.Year - a.Year)[0];
            }

            function resetHighlights(){
                svg.selectAll("circle").transition().duration(400).style("opacity",0.9).attr("r",d=>d? sizeScale(d.EV) : 3);
            }

            function highlightCountry(d){
                if(!d) return;
                svg.selectAll("circle").transition().duration(500)
                    .style("opacity",c=>(c.Country===d.Country?1:0.1))
                    .attr("r", c => (c && c.Country === d.Country ? sizeScale(c.EV)*1.5 : (c? sizeScale(c.EV) : 3)));
                if(d.lat&&d.lon) map.flyTo([d.lat,d.lon],4,{animate:true,duration:1.2});
                const key = d.Country + "|" + d.Year;
                if (markerMap[key]) markerMap[key].openPopup();
            }

            function activateStep(stepId){
                d3.selectAll('.step').classed('is-active',false);
                d3.selectAll('.step').filter(function(){ return this.getAttribute('data-step')===stepId; }).classed('is-active',true);
                resetHighlights();

                // If the controls exist, perform filter actions
                const regionSelectEl = document.querySelector('#regionSelect');
                const yearSelectEl = document.querySelector('#yearSelect');

                switch(stepId) {
                    case "intro":
                        if (map) map.flyTo([20,0],3,{animate:true,duration:1});
                        if (regionSelectEl) { regionSelectEl.value = "All regions"; regionSelectEl.dispatchEvent(new Event('change')); }
                        if (yearSelectEl) { yearSelectEl.value = "All years"; yearSelectEl.dispatchEvent(new Event('change')); }
                        break;
                    case "global":
                        if (map) map.flyTo([20,0],3,{animate:true,duration:1.2});
                        if (regionSelectEl) { regionSelectEl.value = "All regions"; regionSelectEl.dispatchEvent(new Event('change')); }
                        break;
                    case "europe":
                        if (regionSelectEl) { regionSelectEl.value = "Europe"; regionSelectEl.dispatchEvent(new Event('change')); }
                        break;
                    case "northamerica":
                        if (regionSelectEl) { regionSelectEl.value = "North America"; regionSelectEl.dispatchEvent(new Event('change')); }
                        break;
                    case "asiapacific":
                        if (regionSelectEl) { regionSelectEl.value = "Asia & Pacific"; regionSelectEl.dispatchEvent(new Event('change')); }
                        break;
                    case "clusters":
                        if (map) map.flyTo([54, 15], 3, { animate: true, duration: 1.2 });
                        if (regionSelectEl) {
                            regionSelectEl.value = "Europe";
                            regionSelectEl.dispatchEvent(new Event('change'));
                        }
                        updateMap(currentData, { suppressFitBounds: true });
                        break;

                    case "local":
                        if (regionSelectEl) {
                            regionSelectEl.value = "North America";
                            regionSelectEl.dispatchEvent(new Event('change'));
                        }
                        updateMap(currentData, { suppressFitBounds: true });
                        break;

                    case "anomalies":
                        if (map) map.flyTo([35, 103], 3, { animate: true, duration: 1.5 });
                        if (regionSelectEl) {
                            regionSelectEl.value = "Asia & Pacific";
                            regionSelectEl.dispatchEvent(new Event('change'));
                        }
                        updateMap(currentData, { suppressFitBounds: true });
                        break;
                    case "cautions":
                        if (regionSelectEl) { regionSelectEl.value = "All regions"; regionSelectEl.dispatchEvent(new Event('change')); }
                        break;
                    case "conclusion":
                        if (map) map.flyTo([20,0],2,{animate:true,duration:1});
                        if (regionSelectEl) { regionSelectEl.value = "All regions"; regionSelectEl.dispatchEvent(new Event('change')); }
                        break;
                }
            }

            const storyPanel = document.querySelector('#story-panel');
            const steps = storyPanel.querySelectorAll('.step');
            
            // Make cards clickable by user
            steps.forEach(step => {
                step.addEventListener('click', () => {
                    const id = step.getAttribute('data-step');
                    activateStep(id);
                });
            });

            // =============================
            // Task 19: Testing & Validation
            // =============================

            function runVisualizationTests() {
                console.group("=== Visualization Testing ===");

                // Test xScale mapping
                try {
                    console.assert(xScale(50) >= 0 && xScale(50) <= innerW, "xScale out of range");
                    console.log("xScale mapping test passed");
                } catch(e) {
                    console.error("xScale mapping test failed:", e);
                }

                // Test yScale mapping
                try {
                    console.assert(yScale(1000) >= 0 && yScale(1000) <= innerH, "yScale out of range");
                    console.log("yScale mapping test passed");
                } catch(e) {
                    console.error("yScale mapping test failed:", e);
                }

                // Test safeOffsets function
                try {
                    const offsets = safeOffsets(innerW * 0.8, 10);
                    console.assert(offsets.dx < 0, "safeOffsets dx should be negative near right edge");
                    console.log("safeOffsets test passed");
                } catch(e) {
                    console.error("safeOffsets test failed:", e);
                }

                // Test filterData for year & region
                try {
                    const testData = currentData.filter(d => d.Year === 2015 && d.Region === "Europe");
                    console.assert(testData.every(d => d.Year === 2015 && d.Region === "Europe"), "filterData logic failed");
                    console.log("filterData logic test passed");
                } catch(e) {
                    console.error("filterData logic test failed:", e);
                }
                console.groupEnd();
            }
        </script>
    </body>
</html>